#! /bin/bash
# all customized function collect at this file

dCount() {

    find "$1" -type d -print0 | while read -d '' -r dir; do
        files=("$dir"/*)
        printf "%5d files in directory %s\n" "${#files[@]}" "$dir"
    done
}

dirdiff() {
    # Shell-escape each path:
    DIR1=$(printf '%q' "$1")
    shift
    DIR2=$(printf '%q' "$1")
    shift
    nvim "$@" -c "DirDiff $DIR1 $DIR2"
}

create_venv() {
    if [ ! -d ~/venv/ ]; then
        echo "Creating ~/venv/ for python venv"
        mkdir ~/venv/
    fi
}

# this function is written by AI
mkvenv() {
    local force=0
    local python_version=""
    local name=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -f | --force)
            force=1
            shift
            ;;
        -p | --python)
            python_version="$2"
            shift 2
            ;;
        -*)
            echo "❌ Unknown option: $1" >&2
            return 1
            ;;
        *)
            name="$1"
            shift
            ;;
        esac
    done

    # Default name to current folder name
    if [[ -z "$name" ]]; then
        name="$(basename "$PWD")"
    fi

    local venv_root="$HOME/venv"
    local venv_path="$venv_root/$name"
    local python_exec="python3"

    if [[ -n "$python_version" ]]; then
        python_exec="python$python_version"
    fi

    # Check if Python executable exists
    if ! command -v "$python_exec" > /dev/null 2>&1; then
        echo "❌ Python interpreter not found: $python_exec" >&2
        return 3
    fi

    mkdir -p "$venv_root"

    if [[ -e "$venv_path" ]]; then
        if [[ $force -eq 1 ]]; then
            echo "⚠️  Removing existing virtual environment at: $venv_path"
            rm -rf "$venv_path"
        else
            echo "❌ Virtual environment already exists at: $venv_path" >&2
            echo "   Use -f to overwrite." >&2
            return 1
        fi
    fi

    "$python_exec" -m venv "$venv_path" || {
        echo "❌ Failed to create virtual environment using $python_exec" >&2
        return 2
    }

    echo "✅ Virtual environment created at: $venv_path using $python_exec"
}

venv() {
    # specified which venv will be used
    if [ -e ~/venv/"$1"/bin/activate ]; then
        . ~/venv/"$1"/bin/activate
        return 0
    fi

    # recursively to find venv in the current working directory
    p='-' # any string as init
    until [ "$p" == '/' ]; do
        if [ "$p" == '-' ]; then # init as
            p=$PWD
        else
            p=$(dirname "$p")
        fi

        #echo $p
        #echo ${p##*/}

        if [ -e ~/venv/"${p##*/}"/bin/activate ]; then
            . ~/venv/"${p##*/}"/bin/activate
            break
        fi
    done
}
export -f venv

nonascii() {
    # gnu grep ( MacOS need to `brew install grep`, and use `ggrep` instead of `grep` )
    #LANG=C grep -P '[^\x00-\x7f]' -R . --exclude-dir=".git"

    # rg ( short for ripgrep )
    #LANG=C rg -P '[^\x00-\x7f]'
    LANG=C rg -g '!.git' '[^[:ascii:]]'
}

nonewline() {
    # find . -type f -print0 | xargs -0 -L1 bash -c 'test "$(tail -c 1 "$0")" && echo "No new line at end of $0"'
    find . -type f -print0 | xargs -0 -L1 bash -c 'test "$(tail -c 1 "$0")" && echo "$0"'
}

showOS() {
    unameOut="$(uname -s)"
    case "$unameOut" in
    Linux*) awk -F= '/^NAME/{print $2}' /etc/os-release ;;
    Darwin*) echo Mac ;;
    *)
        echo "UNKNOWN:${unameOut}"
        ;;
    esac
    uname -m
}

checksum() {
    echo md5
    md5sum "$1"
    echo sha1
    sha1sum "$1"
    echo sha256
    sha256sum "$1"
}

# git worktree co [worktree name]
wco() {
    target=$(git worktree list | awk '{print $1}' | sort | head -1)
    if [ $# -ne 0 ]; then
        target="${target}_$1"
    fi

    tmpfile=$(mktemp)
    echo "#!/bin/bash" > "$tmpfile"
    echo "cd $target" >> "$tmpfile"
    . "$tmpfile" # do the cd
    echo "cd $target"
    rm -f -- "$tmpfile"
}

swagweb() {
    swag init -d web -g web.go --parseDependency --parseInternal --parseDepth 3 --markdownFiles ./docs
    rm -f docs/docs.go
    python3 -m http.server -d docs 8081
}

helmChartCheck() {
    echo "check file 'charts/app/values.yaml' which variable is not used in template"
    # check value file variables in template
    for var in $(yq -o=props '... comments=""' charts/app/values.yaml | awk '{print $1}'); do
        #echo $var
        grep -r ".Values.$var" ./charts/app/templates/ > /dev/null
        if [ $? -ne 0 ]; then
            echo "Unused variable: $var"
        fi
    done

    # check template variables in value file
    # grep -r  '{{ .* }}' charts/app/templates/
}
