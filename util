#! /bin/bash
# all customized function collect at this file

dCount() {

    find "$1" -type d -print0 | while read -d '' -r dir; do
        files=("$dir"/*)
        printf "%5d files in directory %s\n" "${#files[@]}" "$dir"
    done
}

dirdiff() {
    # Shell-escape each path:
    DIR1=$(printf '%q' "$1")
    shift
    DIR2=$(printf '%q' "$1")
    shift
    nvim "$@" -c "DirDiff $DIR1 $DIR2"
}

create_venv() {
    if [ ! -d ~/venv/ ]; then
        echo "Creating ~/venv/ for python venv"
        mkdir ~/venv/
    fi
}

# this function is written by AI
mkvenv() {
    local force=0
    local python_version=""
    local name=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -f | --force)
            force=1
            shift
            ;;
        -p | --python)
            python_version="$2"
            shift 2
            ;;
        -*)
            echo "❌ Unknown option: $1" >&2
            return 1
            ;;
        *)
            name="$1"
            shift
            ;;
        esac
    done

    # Default name to current folder name
    if [[ -z "$name" ]]; then
        name="$(basename "$PWD")"
    fi

    local venv_root="$HOME/venv"
    local venv_path="$venv_root/$name"
    local python_exec="python3"

    if [[ -n "$python_version" ]]; then
        python_exec="python$python_version"
    fi

    # Check if Python executable exists
    if ! command -v "$python_exec" > /dev/null 2>&1; then
        echo "❌ Python interpreter not found: $python_exec" >&2
        return 3
    fi

    mkdir -p "$venv_root"

    if [[ -e "$venv_path" ]]; then
        if [[ $force -eq 1 ]]; then
            echo "⚠️  Removing existing virtual environment at: $venv_path"
            rm -rf "$venv_path"
        else
            echo "❌ Virtual environment already exists at: $venv_path" >&2
            echo "   Use -f to overwrite." >&2
            return 1
        fi
    fi

    "$python_exec" -m venv "$venv_path" || {
        echo "❌ Failed to create virtual environment using $python_exec" >&2
        return 2
    }

    echo "✅ Virtual environment created at: $venv_path using $python_exec"
}

venv() {
    # specified which venv will be used
    if [ -e ~/venv/"$1"/bin/activate ]; then
        . ~/venv/"$1"/bin/activate
        return 0
    fi

    # recursively to find venv in the current working directory
    p='-' # any string as init
    until [ "$p" == '/' ]; do
        if [ "$p" == '-' ]; then # init as
            p=$PWD
        else
            p=$(dirname "$p")
        fi

        #echo $p
        #echo ${p##*/}

        if [ -e ~/venv/"${p##*/}"/bin/activate ]; then
            . ~/venv/"${p##*/}"/bin/activate
            break
        fi
    done
}
export -f venv

nonascii() {
    # gnu grep ( MacOS need to `brew install grep`, and use `ggrep` instead of `grep` )
    #LANG=C grep -P '[^\x00-\x7f]' -R . --exclude-dir=".git"

    # rg ( short for ripgrep )
    #LANG=C rg -P '[^\x00-\x7f]'
    LANG=C rg -g '!.git' '[^[:ascii:]]'
}

nonewline() {
    # find . -type f -print0 | xargs -0 -L1 bash -c 'test "$(tail -c 1 "$0")" && echo "No new line at end of $0"'
    find . -type f -print0 | xargs -0 -L1 bash -c 'test "$(tail -c 1 "$0")" && echo "$0"'
}

showSystemInfo() {
    local os arch distro uname_out

    uname_out="$(uname -s)"
    arch="$(uname -m)"

    case "${uname_out}" in
    Linux*)
        os="Linux"
        if [[ -f /etc/os-release ]]; then
            . /etc/os-release
            distro="${NAME} ${VERSION}"
        elif command -v lsb_release > /dev/null 2>&1; then
            distro="$(lsb_release -d | cut -f2)"
        else
            distro="Unknown Linux distribution"
        fi
        ;;
    Darwin*)
        os="macOS"
        # macOS version from sw_vers
        if command -v sw_vers > /dev/null 2>&1; then
            distro="$(sw_vers -productName) $(sw_vers -productVersion)"
        else
            distro="macOS (version unknown)"
        fi
        ;;
    *)
        os="Unknown:${uname_out}"
        distro="N/A"
        ;;
    esac

    echo "Operating System: ${os}"
    echo "Architecture: ${arch}"
    [[ "${distro}" != "N/A" ]] && echo "Distribution: ${distro}"
}

checksum() {
    echo md5
    md5sum "$1"
    echo sha1
    sha1sum "$1"
    echo sha256
    sha256sum "$1"
}

# git worktree co [worktree name]
wco() {
    target=$(git worktree list | awk '{print $1}' | sort | head -1)
    if [ $# -ne 0 ]; then
        target="${target}_$1"
    fi

    tmpfile=$(mktemp)
    echo "#!/bin/bash" > "$tmpfile"
    echo "cd $target" >> "$tmpfile"
    . "$tmpfile" # do the cd
    echo "cd $target"
    rm -f -- "$tmpfile"
}

swagweb() {
    swag init -d web -g web.go --parseDependency --parseInternal --parseDepth 3 --markdownFiles ./docs
    rm -f docs/docs.go
    python3 -m http.server -d docs 8081
}

helmChartCheck() {
    echo "check file 'charts/app/values.yaml' which variable is not used in template"
    # check value file variables in template
    for var in $(yq -o=props '... comments=""' charts/app/values.yaml | awk '{print $1}'); do
        #echo $var
        grep -r ".Values.$var" ./charts/app/templates/ > /dev/null
        if [ $? -ne 0 ]; then
            echo "Unused variable: $var"
        fi
    done

    # check template variables in value file
    # grep -r  '{{ .* }}' charts/app/templates/
}

# Open 3-pane Vim comparing two files via `comm`
comm2vim() {
    # --- usage helper ---
    _comm2vim_usage() {
        cat << 'EOF'
Usage: comm2vim [-i] <file1> <file2>

Opens Vim with 3 panes:
- top-left  : lines unique to file1
- top-right : lines unique to file2
- bottom    : lines common to both

Options:
  -i   case-insensitive compare (fold case in sorting)

Notes:
- Inputs are internally sorted before running `comm` (required by `comm`).
- Temp files are cleaned up when you exit Vim.
EOF
    }

    # --- parse args ---
    local case_insensitive=0 opt
    while getopts ":ih" opt; do
        case "$opt" in
        i) case_insensitive=1 ;;
        h | *)
            _comm2vim_usage
            return 0
            ;;
        esac
    done
    shift $((OPTIND - 1))

    if [ "$#" -ne 2 ]; then
        _comm2vim_usage
        return 1
    fi

    local f1=$1 f2=$2
    if [ ! -f "$f1" ] || [ ! -f "$f2" ]; then
        echo "error: both arguments must be files" >&2
        return 2
    fi

    t1=$(mktemp)
    t2=$(mktemp)
    u1=$(mktemp -t only_in_file1)
    u2=$(mktemp -t only_in_file2)
    cm=$(mktemp -t common_in_both)

    # --- sort inputs for comm ---
    if [ "$case_insensitive" -eq 1 ]; then
        LC_ALL=C sort -f -- "$f1" > "$t1"
        LC_ALL=C sort -f -- "$f2" > "$t2"
    else
        LC_ALL=C sort -- "$f1" > "$t1"
        LC_ALL=C sort -- "$f2" > "$t2"
    fi

    # --- compute columns with comm ---
    #  col 1: only in file1  => suppress col2&3 (-23)
    #  col 2: only in file2  => suppress col1&3 (-13)
    #  col 3: in both        => suppress col1&2 (-12)
    comm -23 "$t1" "$t2" > "$u1"
    comm -13 "$t1" "$t2" > "$u2"
    comm -12 "$t1" "$t2" > "$cm"

    # --- open editor in 3 panes ---
    # Layout: open $u1, split bottom with $cm, then v-split right with $u2, focus left
    nvim "$f1" "$f2" -O \
        -c "tabnew $u1" \
        -c "sp $cm" \
        -c "wincmd k" \
        -c "vsp $u2" \
        -c "wincmd h"
}

_wco_completions() {
    echo ${#COMP_WORDS[@]}
    if [ "${#COMP_WORDS[@]}" != "2" ]; then
        return
    fi
    COMPREPLY+=("now")
    COMPREPLY+=("tomorrow")
    COMPREPLY+=("never")
}

complete -F _wco_completions wco

excalidraw() {
    docker run --rm -dit --name excalidraw -p 5000:80 excalidraw/excalidraw:latest
    open http://localhost:5000
}

jwt-decode() {
    # https://gist.github.com/angelo-v/e0208a18d455e2e6ea3c40ad637aac53
    jq -R 'split(".") | .[1] | @base64d | fromjson' <<< "$1"
}
